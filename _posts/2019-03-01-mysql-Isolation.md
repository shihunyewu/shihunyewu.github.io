---
layout:     post
title:      "Mysql-Isolation"
subtitle:   " \"Mysql 中的隔离级别\""
date:       2019-03-01 11:11:11
author:     "shihunyewu"
header-img: "img/post-bg-unix-linux.jpg"
catalog: false
tags:
    - MySql
---
> Mysql 中的隔离级别

## Mysql 中的隔离级别
### 四种隔离级别
##### 读未提交
A 事务读取数据集时， B 事务对数据集修改后，还未提交，但是 A 事务已经能够读取到 B 事务级对数据集的修改。这里存在的问题也叫做脏读。
##### 读已提交
事务原子化，B 事务完全提交后，A 事务才可以读取。能够解决脏读问题，无法解决重复读问题。
##### 可重复读
事务 A 中，对数据集的两次读取操作得到的数据集相同。只针对 A 操作过的数据。无法解决幻读问题。
##### 串行化读
事务执行串行化。

### 三种问题
##### 脏读
读到事务操作的中间结果
##### 不可重复读
事务中第一次读取到的数据集和第二次读取到的数据集不同
##### 幻读
解决可重复读问题时，第一次读取数据时，会将引用到的行数据锁定，直到整个事务结束。但是无法锁定未指定的行。
举例：
1. A 事务，第一次 查询 2019 年之前的记录，得到一个结果集，然后对这个结果集全部做了修改。
2. B 事务，向表内添加了一条 2018 年的记录，修改了结果集
3. A 事务不知道 B 事务的行为，A 仍认为 2019年之前的事务都已经全部修改成功，然后重新查找 2019 年之前的数据，会发现一个没有修改过的 B 插入的记录，因此发生了幻读。


### MVCC(多版本控制并发)
为了实现提交读和可重复读，InnoDB 使用 MVCC 机制。
#### 版本号
- 系统版本号，假定为 n_s
- 事务版本号，假定为 n_t
每一个数据行都有两个隐藏列，一个存放创建版本号，一个存放删除版本号
- 创建版本号，假定为 n_c
- 删除版本号，假定为 n_d

#### 系统版本号和事务版本号的获取规则
1. 系统版本号，是一个递增的数字，每次事务执行完成，系统版本号自动递增。
2. 事务版本号，事务开始时系统版本号。

#### 实现过程
##### 1. SELECT
当前事务版本号为 n_t，如果
- n_t > n_c，有效，说明的当前事务读取到的行是当前事务开始之前创建的数据行
- n_t <= n_c，无效，说明当前事务开始后，有别的事务对数据行进行了修改，事务回滚
- n_t < n_d，有效，说明是事务开始之后，才被其他事务删除
- n_t <= n_d，无效，说明事务开始之前，该数据行已经被删除，不应该去读取这个

##### 2. INSERT
当前行的 n_c = n_s

##### 3. DELETE
当前行的 n_d = n_s

##### 4. UPDATE
当前行的 n_d = n_s，n_c = n_s

#### 回滚
使用 Undo 日志将每个事务的快照保存下来，通过回滚指针将所有快照连接起来，以便回滚。
